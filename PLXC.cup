import java_cup.runtime.*;
import java.util.*;

action code	{:
				/* Variables */
				public static int varTemp = 0;

				/* Methods */
				private static String newVarTemp() {
					return "$t" + (varTemp++);
				}

				private String genTAC(String tac){
					String temp = newVarTemp(); 
					PLXC.out.println("\t" + temp + tac); 
					return temp;
				}

				private LabelPair genCondition(String fexp, String sexp, String binop, Boolean swap){
					LabelPair lp = new LabelPair(); 
					String labels = (swap)	?	lp.getLabelFalse() + ";\n\tgoto " + lp.getLabelTrue() :
											 	lp.getLabelTrue() + ";\n\tgoto " + lp.getLabelFalse();
					PLXC.out.println("\tif (" + fexp + binop + sexp + ") goto " + labels + ";");
					return lp;
				}

				private String newLabel() {
					return Yylex.newLabel();
				}

				/* Classes */
				public static class LabelPair {
					private String labelTrue;
					private String labelFalse;

					public LabelPair(){
						labelTrue = Yylex.newLabel();
						labelFalse = Yylex.newLabel();
					}
				
					public String getLabelTrue() {
						return labelTrue;
					}

					public String getLabelFalse() {
						return labelFalse;
					}

					public void swapLabels() {
						String aux = labelTrue;
						labelTrue = labelFalse;
						labelFalse = aux;
					}
				}

				//

				public static class Scopes {
					private static ArrayList<TokensTable> scopes = new ArrayList<TokensTable>();

					public static void newScope(){
						scopes.add(new TokensTable());
					}

					public static void removeScope(){
						scopes.remove(scopes.size() - 1);
					}
					
					public static TokensTable currentScope(){
						return scopes.get(scopes.size() - 1);
					}

					public static Token find(String name, Boolean current){
						Token t = null;
						int i = scopes.size() - 1; // by default, search in all scopes
						if (!current) i--; // for searching excluding the current scope
						while (i >= 0){
							t = scopes.get(i).extract(name);
							if (t != null) return t;
							i--;
						}
						return t;
					}

					public static void declare(String id, String e, Boolean print){
						if (currentScope().extract(id) != null) { 
							error(); // redeclaring in the same scope
						} else {
							if (find(id, true) != null){ 
								id = id + "_" + scopes.size();
								currentScope().add(id, "int");
							} else {
								currentScope().add(id, "int");
							}
						}
						if (print) PLXC.out.println("\t" + id + " = " + e + ";");
					}

					public static void error() {
						System.out.println("\terror;");
					}

					public static String getVariable(String id){
					String lastName = id + "_";
					int idxLastScope = scopes.size()-1;

					// Searching id_currentScope, id_currentScope-1, id_currentScope-2 ...
					for (int i = idxLastScope; i >= 0; i--){
						if (scopes.get(i).extract(lastName + (i+1)) != null)
							return (lastName + (i+1)); // redeclaration
					}
					return id;
				}

				}

			:}

// TERMINALS

terminal INT;
terminal PRINT, ELSE, WHILE, DO, FOR; 
terminal String IF;
terminal OP, CP, OB, CB;
terminal ADD, SUB, MUL, DIV, UMIN, SC, ASIG, COMMA, INCR, DECR, MOD;
terminal DEQ, LT, LEQ, GT, GEQ, NEQ, AND, OR, NOT;
terminal String NUM, ID;

// NON TERMINALS

non terminal Object program, sent_list, sentence, optionalElse;
non terminal String expr;
non terminal Token declaration;
non terminal LabelPair cond;

// PRECEDENCES

precedence left OR;
precedence left AND;
precedence right NOT;
precedence left ADD, SUB;
precedence left DIV, MUL, MOD;
precedence right UMIN;
precedence left ELSE;
precedence left OP, CP;

// GRAMMAR

program			::=	{: Scopes.newScope(); :} sent_list
; 

sent_list		::= sentence
				| 	sent_list sentence	
;

sentence		::= expr:e SC	
						{:
							RESULT = e;
						:}
				| 	PRINT OP expr:e CP SC	
						{: 
							PLXC.out.println("\tprint " + e + ";"); 
						:}
				|	IF:labEnd OP cond:c CP 
						{:
							PLXC.out.println(c.getLabelTrue() + ":"); 
						:}
					sentence 
						{:
							PLXC.out.println("\tgoto " + labEnd + ";"); 
							PLXC.out.println(c.getLabelFalse() + ":");
						:}
					optionalElse
						{:
							PLXC.out.println(labEnd + ":"); 
						:}
				| 	OB {: Scopes.newScope(); :} sent_list CB {: Scopes.removeScope(); :}
				|   WHILE:labIniWhile 
						{:
							PLXC.out.println(labIniWhile + ":");
						:}
					OP cond:c CP 
						{:
							PLXC.out.println(c.getLabelTrue() + ":"); 
						:}
					sentence
						{:
							PLXC.out.println("\tgoto " + labIniWhile + ";"); 
							PLXC.out.println(c.getLabelFalse() + ":");
						:}
				|	DO:labIniDo 
						{:
							PLXC.out.println(labIniDo + ":");
						:}
					sentence WHILE OP cond:c CP SC
						{:
							PLXC.out.println(c.getLabelTrue() + ":"); 
							PLXC.out.println("\tgoto " + labIniDo + ";"); 
							PLXC.out.println(c.getLabelFalse() + ":");
						:}
				|	FOR:labIniFor OP expr 
						{:
							PLXC.out.println(labIniFor + ":");
						:}
					SC cond:c
						{:
							String labIncrFor = Yylex.newLabel();
							PLXC.out.println(labIniFor + "_" + ":");
						:}
					SC expr 
						{: 
							PLXC.out.println("\tgoto " + labIniFor + ";"); 
							PLXC.out.println(c.getLabelTrue() + ":"); 
						:}	
					CP sentence 
						{:
							PLXC.out.println("\tgoto " + labIniFor + "_" + ";"); 
							PLXC.out.println(c.getLabelFalse() + ":"); 
						:}
				|	declaration SC
;

optionalElse	::= ELSE sentence
				| /*epsilon*/
;


expr			::= expr:e1 ADD expr:e2
						{:
							RESULT = genTAC(" = " + e1 + " + " + e2 + ";");
						:}
				|	expr:e1 SUB expr:e2
						{:
							RESULT = genTAC(" = " + e1 + " - " + e2 + ";");
						:}
				|	expr:e1 MUL expr:e2
						{:
							RESULT = genTAC(" = " + e1 + " * " + e2 + ";");
						:}
				|	expr:e1 DIV expr:e2
						{:
							RESULT = genTAC(" = " + e1 + " / " + e2 + ";");
						:} 
				|	OP expr:e CP
						{: 
							RESULT = e;
						:}
				|	SUB expr:e
						{:
							RESULT = genTAC(" = -" + e + ";");
						:} %prec UMIN
				| 	ID:id	
						{: 
							if (Scopes.find(id, true) != null){
								RESULT = Scopes.getVariable(id);
							} else {
								Scopes.error();
								RESULT = null;
							}
						:}
				| 	NUM:num	
						{: 
							RESULT = num; 
						:}
				|	ID:id ASIG expr:e 
						{:
							if (Scopes.find(id, true) != null){
								String var_name = Scopes.getVariable(id);
								PLXC.out.println("\t" + var_name + " = " + e + ";"); 
								RESULT = var_name;
							} else {
								Scopes.error();
							}
						:}
				|	INCR ID:id
						{:
							PLXC.out.println("\t" + id + " = " + id + " + 1" + ";"); 
							RESULT = id;
						:}
				|	ID:id INCR
						{:
							String temp = newVarTemp();
							PLXC.out.println("\t" + temp + " = " + id + ";"); 
							PLXC.out.println("\t" + id + " = " + id + " + 1" + ";"); 
							RESULT = temp;
						:}
				|	DECR ID:id
						{:
							PLXC.out.println("\t" + id + " = " + id + " - 1" + ";"); 
							RESULT = id;
						:}
				|	ID:id DECR
						{:
							String temp = newVarTemp();
							PLXC.out.println("\t" + temp + " = " + id + ";"); 
							PLXC.out.println("\t" + id + " = " + id + " - 1" + ";"); 
							RESULT = temp;
						:}
				|	OP ID:id CP INCR	
						{: 
							String temp = newVarTemp();
							PLXC.out.println("\t" + temp + " = " + id + ";"); 
							PLXC.out.println("\t" + id + " = " + id + " + 1" + ";"); 
							RESULT = temp;	
						:}
				|	OP ID:id CP DECR	
						{: 
							String temp = newVarTemp();
							PLXC.out.println("\t" + temp + " = " + id + ";"); 
							PLXC.out.println("\t" + id + " = " + id + " - 1" + ";"); 
							RESULT = temp;	
						:}
				|	INCR OP ID:id CP	
						{: 
							PLXC.out.println("\t" + id + " = " + id + " + 1" + ";"); 
							RESULT = id;	
						:}
				|	DECR OP ID:id CP	
						{: 
							PLXC.out.println("\t" + id + " = " + id + " - 1" + ";"); 
							RESULT = id;	
						:}
				|	expr:e1 MOD expr:e2
						{:
							String temp1 = genTAC(" = " + e1 + " / " + e2 + ";");
							String temp2 = genTAC(" = " + temp1 + " * " + e2 + ";");
							RESULT = genTAC(" = " + e1 + " - " + temp2 + ";");
						:}	
;

cond			::= expr:e1 DEQ expr:e2
						{:
							RESULT = genCondition(e1, e2, " == ", false);
						:}
				|	expr:e1 NEQ expr:e2
						{:
							RESULT = genCondition(e1, e2, " == ", true);
						:}
				|	expr:e1 LT expr:e2
						{:
							RESULT = genCondition(e1, e2, " < ", false);
						:}
				|	expr:e1 LEQ expr:e2
						{:
							RESULT = genCondition(e2, e1, " < ", true);
						:}
				|	expr:e1 GT expr:e2
						{:
							RESULT = genCondition(e2, e1, " < ", false);
						:}
				|	expr:e1 GEQ expr:e2
						{:
							RESULT = genCondition(e1, e2, " < ", true);
						:}
				|	cond:c1 AND
						{: 
							PLXC.out.println(c1.getLabelTrue() + ":");
						:}
					cond:c2
						{:
							PLXC.out.println(c1.getLabelFalse() + ":");
							PLXC.out.println("\tgoto " + c2.getLabelFalse() + ";");
							RESULT = c2;
						:}
				|	cond:c1 OR
						{: 
							PLXC.out.println(c1.getLabelFalse() + ":");
						:}
					cond:c2
						{:
							PLXC.out.println(c1.getLabelTrue() + ":");
							PLXC.out.println("\tgoto " + c2.getLabelTrue() + ";");
							RESULT = c2;
						:}
				|	NOT cond:c 
						{:
							c.swapLabels();
							RESULT = c;
						:}
;

declaration		::= INT ID:id 
						{:
							Scopes.declare(id, "0", false);
						:}
				|	declaration COMMA ID:id 
						{:
							Scopes.declare(id, "0", false);
						:}		
				|	INT ID:id ASIG expr:e
						{:
							Scopes.declare(id, e, true);
						:}
				|	declaration COMMA ID:id ASIG expr:e
						{:
							Scopes.declare(id, e, true);
						:}
;
